<html>
<style>
body {
  width: 960px;
  margin-top: 50pt;
  margin-left: 50pt;
  counter-reset: h2 h3 h4;
}
h2:before {
    counter-increment: h2;
    content: counter(h2) ". ";
}
h2 {
    counter-reset: h3 h4;
}
h3:before {
    counter-increment: h3;
    content: counter(h2) "." counter(h3) ". ";
    counter-reset: h4;
}
h3 {
    counter-reset: h4;
}
h4:before {
    counter-increment: h4;
    content: counter(h2) "." counter(h3) "." counter(h4) ". ";
}
pre {
  background-color: lightgray;
}
.ednote:before {
  content: "Ed. Note: ";
  font-weight: bold;
}
.ednote {
  font-style: italic;
  background-color: palegreen;
}
</style>

<head>
    <title>SDShare - A Protocol for the syndication of resource descriptions</title>
</head>

<body>
  <div class="header">
    <h1 class="title">SDShare - A Protocol for the syndication of resource descriptions</h1>
    <div class="version">Version 1.0 (in progress)</div>
    <div class="date">Date: 2012-02-17</div>
    <div class="author">Author: Graham Moore</div>
    <div class="author">Author: Lars Marius Garshol</div>
  </div>

  <div class="section">
    <h2 class="title">Abstract</h2>
    <p>
      SDShare is a protocol for the syndication of resource descriptions. It defines how a RESTful service can publish a series of feeds that list snapshots and changes to collections of resources. This protocol also defines how a client should process those feeds and the linked resource descriptions so that a local store is in sync.
    </p>    
  </div>

  <div class="section">
    <h2>Normative References</h2>
    <p>The following lists works upon which this specification is dependent.</p>
    <ul>
        <li>HTTP: <a href="http://www.ietf.org/rfc/rfc2616.txt">RFC</a>,
            2616 HTTP 1.1. September 2004.</li>
        <li>Atom: <a href="http://www.ietf.org/rfc/rfc4287.txt">RFC  4287</a>,
            The Atom Syndication Format. December 2005.</li>
        <li>RDF: <a href="http://www.w3.org/TR/rdf-concepts/">Resource
            Description Framework (RDF):
            Concepts and Abstract Syntax</a>. February 2004</li>
        <li>NTriples: <a href="http://www.w3.org/TR/rdf-testcases/#ntriples"
           >RDF Test Cases</a>, W3C Recommendation, 10 February 2004</li>
        <li>RDFXml: <a href="http://www.w3.org/TR/REC-rdf-syntax/">RDF/XML
            Syntax Specification (Revised)</a>, W3C Recommendation,
            10 February 2004
           </li>
        <li>RFC 5005: <a href="http://www.ietf.org/rfc/rfc5005.txt"
            >Feed Paging and Archiving</a>, IETF Standard, September 2007</li>
    </ul>
  </div>

  <div class="section">
    <h2>Introduction</h2>
    <p>RDF provides a very flexible data model that allows data of any form to be represented. The existing RDF family of standards define how to serialise the model, how to query the model (SPARQL) and how to update the model (SPARQL Update). However, there are no protocols that define how a machine can both expose and consume RDF in a system of interconnected nodes. A classic use case for this requirement is where one RDF server contains collection of master data and another RDF system wishes to use that data. The master data will change over time. This protocol defines how the master data server can publish the changes to the resources it manages and how a client can consume them to ensure it is in sync.</p>

    <p>A SDShare server should publish the following hierarchy of Atom feeds to expose one or more collection(s) of resource descriptions:
    <ul>
        <li>An overview feed which lists the collections of resource descriptions that the server exposes.</li>
        <li>A collection feed for each collection of resource descriptions that each links to a corresponding snapshots feed and a corresponding fragments feed.</li>
        <li>A snapshots feed for each collection. Each snapshot represents the state of a collection at point of time.</li>
        <li>A resouce update feed for each collection. Each feed entry exists to reflect that the referenced resource has been updated. </li>
    </ul>
    </p>

    <p>
    SDShare also specifies how a client should interpret and process these feeds in order to consume the resource descriptions. A client that wishes to maintain a local resource collection in sync with one held on the server first fetches the most recent snapshot for the required collection. It then subscribes to the update feed for that collection. This feed lists the resource whose state has changed in the underlying resource collection. A client can retrieve the RDF for a updated resource and update its local collection.</p>

    <p class="note">NOTE: the notion of a client and server is solely defined by the responsibilities of each. Thus a given machine can act both as client and server (peer-to-peer scenario) or restrict itself to exactly one of the roles (publish-subscribe scenario).</p>

    <p>The protocol provides no provision against malicious or broken servers. It requires the client to trust all upstream servers.</p>
  </div>

<div class="section">
<h2 class="title">Conceptual Model</h2>

<p class=ednote>Trying this out to see if it works. This section is
very much experimental.</p>

<p>A <dfn>server</dfn> is a node which exposes feeds so that other
nodes can observe and retrieve the state of the data being managed by
the server.<P>

<p>A <dfn>client</dfn> is a node which subscribes to one or more
server nodes and implements the update semantics defined in this
protocol. It is possible for the same node to be both a server and a
client at the same time.</p>

<p>An SDshare server contains a set of collections.
A <dfn>collection</dfn> is a coherent data set, defined by the server
in any way it sees fit. When exposing an RDF database via SDshare, a
natural set of collections to use is to let each graph be a
collection, but any set of collections is allowed.</p>

<p>A <dfn>snapshot</dfn> is a complete representation of a collection
as it existed at some point in time.</p>
</div>
  
  <div class="section">
    <h2 class="title">Protocol</h2>

    <div class="section">
        <h3 class="title">Server Role</h3>
        <p>A compliant server will provide the following Atom 1.0 feeds, resource representation data services and snapshot representation data services.</p>

        <div class="section">
            <h4 class="title">Overview Feed</h4>

            <p>The overview feed lists all collections exposed by the
            server, containing one entry per collection. Each entry
            MUST contain:</p>
            
            <ul>
                <li>A link element with the following attributes;
                rel='http://www.sdshare.org/2012/core/collectionfeed',
                type='application/atom+xml' and href whose value links
                to the collection feed for that collection.</li>
            </ul>            
            
            <p>To conform with the Atom specification the link must also be duplicated with link relation <tt>alternate</tt>.</p>

            <pre>            
Example: 

Http request for server http://example-service.org:
GET /collections

The Atom payload of the overview feed contains an entry for each separate resource collection. 
Each entry has a link to an Atom feed for the specified collection.

Example response body:

&lt;?xml version="1.0" encoding="utf-8"?>
   &lt;feed xmlns="http://www.w3.org/2005/Atom">
   &lt;title>Collection managed by wwww.sdshare.org&lt;/title>
   &lt;link href="http://example-service.org/collections"/>
   &lt;updated>2008-12-13T18:30:02Z&lt;/updated>
   &lt;author>
     &lt;name>SDShare Server&lt;/name>
   &lt;/author>
   &lt;id>http://example-service.org/collections&lt;/id>
   &lt;!-- collection entry -->
   &lt;entry>
     &lt;title>eGovernment Resources Collection&lt;/title>
     &lt;!-- a link to the collection atom feed -->
     &lt;link rel="http://www.sdshare.org/2012/core/collectionfeed" type="application/atom+xml"
           href="http://example-service.org/collections/egov"/>
     &lt;id>urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&lt;/id>
     &lt;updated>2008-12-13T18:30:02Z&lt;/updated>
     &lt;summary>A set of RDF resources describing an eGovernment classification scheme.&lt;/summary>
   &lt;/entry>
   &lt;!-- an entry follows for each collection being exposed.
                ...
   -->
 &lt;/feed>

            </pre>
        </div>

        <div class="section">
            <h4 class="title">Collection Feed</h4>   
        
            <p>A collection feed is a feed representing a collection
            exposed by the server. A feed of this kind lists exactly
            two entries, one entry linking to a snapshots feed and one
            to an updates feed.</p>
            
            <p>
The Atom payload of the response contains two entries, one that links
to a snapshot feed for the collection (the link relation is
<tt>http://www.sdshare.org/2012/core/snapshotsfeed</tt>), and another to
the resources feed of the collection (the link relation is
<tt>http://www.sdshare.org/2012/core/fragmentsfeed</tt>). To conform with
the Atom specification both links must be duplicated with link
relation <tt>alternate</tt>.</p>

            <pre>
Example Http request:
GET http://example-service.org/collections/egov

&lt;feed xmlns="http://www.w3.org/2005/Atom">
  &lt;title>eGov Resource Collection&lt;/title>
  &lt;updated>2008-09-26T11:13:40-01:00&lt;/updated>
  &lt;id>http://sdshare.org/sdshare/collections/egov&lt;/a:id>
  &lt;author>
    &lt;name>SDShare Server&lt;/name>
  &lt;/author>
  &lt;link href="http://sdshare.org/sdshare/collections/egov" rel="self"/>
  &lt;entry>
    &lt;title>eGov Collection Updates&lt;/title>
    &lt;id>http://sdshare.org/sdshare/collections/egov/updates&lt;/a:id>
    &lt;updated>2008-09-11T17:58:39-01:00&lt;/updated>
    &lt;author>
      &lt;name>SDShare Server&lt;/name>
    &lt;/author>
    &lt;link href="http://sdshare.org/sdshare/collections/egov/updates" 
             rel="alternate" type="application/atom+xml"/>
    &lt;link href="http://sdshare.org/sdshare/collections/egov/updates" 
             rel="http://www.egovpt.org/sdshare/fragmentsfeed" type="application/atom+xml"/>
  &lt;/entry>
  &lt;entry>
    &lt;title>eGov Collection Snapshots&lt;/title>
    &lt;id>http://sdshare.org/sdshare/collections/egov/snapshots&lt;/a:id>
    &lt;updated>2008-09-11T17:58:39-01:00&lt;/updated>
    &lt;author>
      &lt;name>SDShare Server&lt;/name>
    &lt;/author>
    &lt;link href="http://sdshare.org/sdshare/collections/egov/snapshots" 
             rel="alternate" type="application/atom+xml"/>
    &lt;link href="http://sdshare.org/sdshare/collections/egov/snapshots" 
             rel="http://www.egovpt.org/sdshare/snapshotsfeed" type="application/atom+xml"/>
  &lt;/entry>
&lt;/feed>
            
            </pre>
        </div>

        <div class="section">
            <h4 class="title">Snapshots Feed</h4>

            <p>The snapshots feed lists all the snapshots of a
            collection that are exposed by this server. Each entry in
            the feed represents a single snapshot. The entry must
            contain at least one link element with a link relation 
            of <tt>'http://www.egovpt.org/sdshare/snapshot'</tt> and a
            <tt>type</tt> attribute specifying the format of the
            snapshot. It must also have an <tt>href</tt> attribute
            that links to the data for the snapshot. The item's
            <tt>updated</tt> element should reflect the time when the
            snapshot was taken.</p>
            
            <pre>
Example Http-request
Server: http://wwww.sdshare.org
GET /collections/egov/snapshots

Example Response:

&lt;?xml version="1.0"?>
 &lt;feed xmlns="http://www.w3.org/2005/Atom" xmlns:sdshare="http://www.egovpt.org/sdshare">
   &lt;title>The Snapshots of the eGovernment Resource Collection&lt;/title>
   &lt;subtitle>A list of all snapshots of this collection&lt;/subtitle>
   &lt;author>
     &lt;name>SDShare Server&lt;/name>
   &lt;/author>
   &lt;updated>2008-07-17T12:15:07.020071Z&lt;/updated>
   &lt;id>http://sdshare.org/collections/egov/snapshots&lt;/id>
   &lt;!-- a link to the feed -->
   &lt;link rel="self" href="http://sdshare.org/collections/egov/snapshots"/>
   &lt;entry>
     &lt;title>Snapshot 2008-07-17&lt;/title>
     &lt;updated>2008-07-17T14:04:42.205299Z&lt;/updated>
     &lt;!-- a link to the snapshot RDF -->
     &lt;link rel="alternate" type="application/rdf+xml"
           href="http://sdshare.org/collections/egov/snapshots/0001"/>
     &lt;id>60a76c80-d300-11d9-b93C-0003939e0af6&lt;/id>
   &lt;/entry>
   &lt;!-- an entry follows for each RDF snapshot being exposed.
                ...
   -->
 &lt;/feed>    
            </pre>
        </div>

        <div class="section">
            <h4>Resources Feed</h4>

<p class=ednote>This is an old-style definintion, from before we
  introduced the conceptual model. Will update if new style is
  approved.</p>
            
<p>The resources feed is an Atom feed. The entries of the feed list
resources that have changed in a given time period. The order of the
entries is undefined.</p>

<p>The Atom specification requires all entries to contain
an <tt>id</tt> element, which must be unique. SDshare adds no further
semantics to this element, and clients are advised to avoid depending
on this element.</p>

<p>The Atom payload contains an entry for each updated resource. Each
entry contains one or more links to the resource and
the <tt>updated</tt> element contains the time at which the resource
was updated. Links to the resource must use the <tt>alternate</tt>
link relationship, and can be in different formats identified with
the <tt>type</tt> attribute, allowing clients to choose their
preferred format.</p>

<p>In addition to the standard Atom elements this protocol introduces
one new element.

The new element is:

<tt>&lt;ResourceUri></tt>: Indicates to a client which resource is
being updated from all those present in the resource representation.
This element MUST occur exactly once as a child element of
each <tt>entry</tt>. (See the fragment update algorithm below for more
information).
            </p>

            <p>The resources feed service accepts an optional request parameter called 'since'. This parameter can be used to specify that the client only wishes to see entries for fragments produced after the time given in the parameter. The effect of this parameter is to remove from the response body <entry> elements with timestamps in the atom:updated element older than the given time.</p>

            <p>Note that links to the service in the collection feed will not include this parameter. Clients must therefore add it to the URL themselves should they wish to use it. The value of the parameter is a datetime value matching the format specified in section 3.3 of the Atom specification.</p>

            <pre>
    Example Service URL (with since): 
    [server]/sdshare/collections/egov/updates?since=2011-03-21T14:49:23Z 

    Example response body:

     &lt;?xml version="1.0"?>
     &lt;feed xmlns="http://www.w3.org/2005/Atom" xmlns:sdshare="http://www.egovpt.org/sdshare">
       &lt;title>Updates feed from the eGovernment Resources Collection&lt;/title>
       &lt;author>
         &lt;name>SDShare Server&lt;/name>
       &lt;/author>
       &lt;updated>2008-07-17T15:47:17.062211Z&lt;/updated>
       &lt;id>28C5DBD8-652A-4617-8C4A-C0FFC49B4475&lt;/id>
       &lt;link rel="self" href="http://sdshare.org/sdshare/collections/egov/updates"/>
       &lt;entry>
       &lt;!-- Best practice: a resource's RDFS Label or the resource uri -->
         &lt;title>Government Spending&lt;/title>
         &lt;!-- the published date and time of the fragment -->
         &lt;updated>2008-07-17T15:55:21.971145Z&lt;/updated>

         &lt;!-- the id value is some unique value -->
         &lt;id>69CD5264-DB78-49c1-A7E4-04EECFA0AA85&lt;/id>
         &lt;link rel="alternate" type="application/rdf+xml"
               href="http://sdshare.org/sdshare/collections/egov/updates?id=http://www.egov.org/concepts/governmentspending"/>
         &lt;sdshare:ResourceUri>http://www.egov.org/concepts/governmentspending&lt;/sdshare:TopicSI>
       &lt;/entry>
       &lt;!-- an entry follows for each changed resouce being exposed                  ...
       -->
     &lt;/feed>
    </pre>

    <p>Supported datatypes are for resource representations are:</p>

    <ul>
        <li>application/rdf+xml: Serialization as RDF/XML
    </ul>

    <p>The resource representation is produced as defined by the
    fragment generation algorithm in section 4.5.1.</p>
    
<p>As the number of changes made to the collection grows, the number
of entries in the resources feed can become very large. To avoid
returning excessively long responses, the server can page the
resources feed, using the conventions defined in RFC 5005. If the feed
is paged, each page must contain one link element with the "next"
relation type. Other link types may also be provided, but this is not
required.</p>
    
        </div>

        <div class="section">
            <h4 class="title">Resource Description Service</h4>        

            <p>The fragment data service is a service that returns a specified resource.</p>

            <pre>
Sample request:
GET [server]/sdshare/collections/egov/updates?id=http://www.egov.org/concepts/governmentspending
ACCEPT-TYPE:plain/nt+text
            </pre>

            <p>Response structure:
                A collection fragment can be represented as a valid XTM 1.0, XTM 2.0 or RDF/XML document.

                The generation of fragments for feeds with RDF/XML payload is described in the RDF subsection below.

                A fragment for a feed with XTM 1.0 or XTM 2.0 payload is created in the context of one or more topics. The following algorithm should be applied when generating a fragment for given topic:

                    Let 'export' mean to create an XTM representation of the TMDM construct
                    Let T be the topic being exported.
                    export T including ALL topicnames, identifiers, and occurrences.
                    for each topicname in T export a topic stub for each name type (if it exists)
                    for each topicname in T export a topic stub for each scope topic (if it exists)
                    for each occurrence in T export a topic stub for the occurrence type (if it exists)
                    for each occurrence in T export a topic stub for each scope topic (if it exists)
                    for each association A in which T plays a role export the association
                    for each association A export a topic stub for the association type
                    for each association A export a topic stub for each topic scope topic
                    for each role R in A export a topic stub for the role type and one for the role player UNLESS the role player is T 

                For each stub topic exported (the following minimum must be exported)

                    export ALL of the topic's identifiers 

                ALL topics (stub or not) MUST have at least one Subject Identifier.

                A server may choose to export more information in the fragment, what is described here is the minimum required.
                </p>
         </div>
     
      </div> <!-- end 4.3 -->     

      <div class="section">
        <h3 class="title">Client Role</h3>
        <p>There are two aspects to client behaviour. The first is consumption of the feeds provided by the service the second is the updating of the local map based on the fragments it retrieves.</p>


        <div class="section">
            <h4>Initialisation</h4>
            <p>When a client first wants to sync with a server it can use the feeds provided to locate the collection of interest, retrieve its full representation and merge it into the local collection it is managing.</p>
        </div>
      
        <div class="section">
            <h4>A Clean Replacement</h4>
            <p>If a client has a local collection that contains semantic descriptions from more than one server and wants to fetch and update the latest full collection from ONE source then it MUST do the following. Apply the delete topic algorithm from below, but apply it to all topics in his local collection. Then proceed in terms of 'A Clean Start', by fetching the collections from the originating servers and merging it in.</p>
        </div>

        <div class="section">
            <h4>A partial update</h4>
            <p>Clients wishing to update their local collection as new changes occur on the server, should process the fragments feed for the appropriate collection. The client MUST record the date and time that it last updated its local copy and then find all Atom entries that have an updated value after that time. For each of these, in time order of most distant to most recent it should apply the following update algorithm.</p>
        </div>

            </section>
     </section>

<div class="section">
  <h3>RDF payload</h3>

<p>This protocol is agnostic to the nature of the payload. This
section describes how the protocol works when the payload used is
RDF.</p>

<p><b>NOTE:</b> While the protocol is payload agnostic, it does not
describe how to interoperate between different semantic payload
representations.</p>

<div class="section">
<h4>The Fragment Generation Algorithm</h4>

<p>To create a RDF fragment for a given resource uses the following
algorithm: include every statement in which the resource is the
subject.</p>

<p class=ednote>This doesn't handle blank nodes. Fix!</p>

</div>
<div class="section">
<h4>The Fragment Update Algorithm</h4>

<p>To update an RDF repository with the new fragment for the given
resource:</p>

<ul>
  <li>Delete all statements in which the resource is the subject from
  the graph,
  <li>Insert the entire fragment into the same graph.
</ul>

<p class=ednote>This doesn't handle blank nodes. Fix!</p>
<p class=ednote>We also haven't said what graph to do this on.</p>
</div>

      </div>

    </div>

    <div class="section">
        <h2>Deployment Guidelines and Best Practices (informative)</h2>
        <p>This document defines no normative rules for the correct deployment of network topologies that build on it. However, this section proposes a few best practices to handle recurrent deployment issues.</p>
        
        <div class="section">
            <h3>Trust and Security</h3>
        
            <p>The protocol assumes that the syndication of semantic descriptions happens with trusted servers. Importing descriptions from untrusted, potentially malicious sources can have serious repercussions including corrupting the client's data. If the protocol is used in P2P scenarios where every node acts both as server and client, this implies that all partners need to trust each other.</p>

            <p>Should the protocol be used to syndicate confidential data, it can be combined with end-to-end encryption between nodes, typically over https. Furthermore, it can leverage existing authentication mechanisms such as basic access authentication over http or https. In particularly sensitive cases it can also be employed over dedicated network connections.</p>

        </div>

    </div>
 </body>
 </html>    




